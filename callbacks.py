from pyrogram import Client, filters
from pyrogram.types import CallbackQuery, InlineKeyboardMarkup, InlineKeyboardButton
from pyrogram.enums import ParseMode, ChatType
import asyncio
import re

# ‡§Ü‡§™‡§ï‡•ã ‡§Ø‡§π‡§æ‡§Ç 'app' ‡§î‡§∞ 'logger' ‡§î‡§∞ ‡§Ö‡§®‡•ç‡§Ø CONFIG ‡§µ‡•á‡§∞‡§ø‡§è‡§¨‡§≤‡•ç‡§∏ ‡§ï‡•ã ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡§®‡§æ ‡§π‡•ã‡§ó‡§æ
# ‡§∏‡•Å‡§®‡§ø‡§∂‡•ç‡§ö‡§ø‡§§ ‡§ï‡§∞‡•á‡§Ç ‡§ï‡§ø ‡§Ü‡§™‡§ï‡•Ä 'config.py' ‡§∏‡•á ‡§Ø‡•á ‡§∏‡§π‡•Ä ‡§¢‡§Ç‡§ó ‡§∏‡•á ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§π‡•ã ‡§∞‡§π‡•á ‡§π‡•à‡§Ç‡•§
from config import (
    app, logger, ASBHAI_USERNAME, ASFILTER_BOT_USERNAME, OWNER_ID, UPDATE_CHANNEL_USERNAME,
    buttons_collection, group_tracking_collection, user_tracking_collection,
    messages_collection, owner_taught_responses_collection, conversational_learning_collection,
    biolink_exceptions_collection, earning_tracking_collection, reset_status_collection
)

# utils.py ‡§∏‡•á ‡§Ü‡§µ‡§∂‡•ç‡§Ø‡§ï ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§® ‡§á‡§Æ‡•ç‡§™‡•ã‡§∞‡•ç‡§ü ‡§ï‡§∞‡•á‡§Ç
from utils import get_top_earning_users, send_and_auto_delete_reply, store_message, update_user_info, update_group_info, is_admin_or_owner


# -----------------------------------------------------
# UTILITY FUNCTIONS FOR SETTINGS
# -----------------------------------------------------

# ‡§Ø‡§π ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§® ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡•ã ‡§∞‡•Ä-‡§ú‡§®‡§∞‡•á‡§ü ‡§î‡§∞ ‡§è‡§°‡§ø‡§ü ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§π‡•à
async def refresh_settings_menu(client: Client, chat_id: int, message_id: int, user_id: int):
    """Fetches current settings, generates the settings keyboard, and edits the message."""
    
    # Check Admin/Owner status again (in case an old button is pressed)
    if not await is_admin_or_owner(client, chat_id, user_id):
        return  # Do nothing if the user is no longer an admin

    # 1. Fetch current settings and default punishment
    current_status_doc = group_tracking_collection.find_one({"_id": chat_id})
    
    # Default values if not found
    bot_enabled = current_status_doc.get("bot_enabled", True) if current_status_doc else True
    linkdel_enabled = current_status_doc.get("linkdel_enabled", False) if current_status_doc else False
    biolinkdel_enabled = current_status_doc.get("biolinkdel_enabled", False) if current_status_doc else False
    usernamedel_enabled = current_status_doc.get("usernamedel_enabled", False) if current_status_doc else False
    
    punishment = current_status_doc.get("default_punishment", "delete") if current_status_doc else "delete"
    
    # Status texts
    bot_status = "‚úÖ ‡§ö‡§æ‡§≤‡•Ç (ON)" if bot_enabled else "‚ùå ‡§¨‡§Ç‡§¶ (OFF)"
    link_status = "‚úÖ ‡§ö‡§æ‡§≤‡•Ç (ON)" if linkdel_enabled else "‚ùå ‡§¨‡§Ç‡§¶ (OFF)"
    biolink_status = "‚úÖ ‡§ö‡§æ‡§≤‡•Ç (ON)" if biolinkdel_enabled else "‚ùå ‡§¨‡§Ç‡§¶ (OFF)"
    username_status = "‚úÖ ‡§ö‡§æ‡§≤‡•Ç (ON)" if usernamedel_enabled else "‚ùå ‡§¨‡§Ç‡§¶ (OFF)"
    
    # Punishment text
    punishment_map = {
        "delete": "üóëÔ∏è ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú",
        "mute": "üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç",
        "warn": "‚ö†Ô∏è ‡§µ‡§æ‡§∞‡•ç‡§® ‡§ï‡§∞‡•á‡§Ç",
        "ban": "‚õîÔ∏è ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç"
    }
    punishment_text = punishment_map.get(punishment, "üóëÔ∏è ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú")

    # 2. Create the Main Settings Keyboard
    keyboard = InlineKeyboardMarkup(
        [
            # Module Toggles
            [
                InlineKeyboardButton(f"ü§ñ ‡§¨‡•â‡§ü ‡§ö‡•à‡§ü‡§ø‡§Ç‡§ó: {bot_status}", callback_data="toggle_setting_bot_enabled"),
            ],
            [
                InlineKeyboardButton(f"üîó ‡§≤‡§ø‡§Ç‡§ï ‡§°‡§ø‡§≤‡•Ä‡§ü: {link_status}", callback_data="toggle_setting_linkdel_enabled"),
            ],
            [
                InlineKeyboardButton(f"üë§ ‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§°‡§ø‡§≤‡•Ä‡§ü: {biolink_status}", callback_data="toggle_setting_biolinkdel_enabled"),
            ],
            [
                InlineKeyboardButton(f"üó£Ô∏è @‡§Ø‡•Ç‡§ú‡§º‡§∞‡§®‡•á‡§Æ ‡§°‡§ø‡§≤‡•Ä‡§ü: {username_status}", callback_data="toggle_setting_usernamedel_enabled"),
            ],
            # Punishment and Biolink Exception
            [
                InlineKeyboardButton(f"üî® ‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ: {punishment_text}", callback_data="open_punishment_settings"),
            ],
            [
                 InlineKeyboardButton("üë§ ‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§õ‡•Ç‡§ü (Exceptions) üìù", callback_data="open_biolink_exceptions")
            ],
            # Close Button
            [
                InlineKeyboardButton("‚ùå ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§¨‡§Ç‡§¶ ‡§ï‡§∞‡•á‡§Ç", callback_data="close_settings")
            ]
        ]
    )

    # 3. Generate the Settings Message
    settings_message = (
        f"‚öôÔ∏è **‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏** üõ†Ô∏è\n\n"
        "‡§®‡§Æ‡§∏‡•ç‡§§‡•á, ‡§¨‡•â‡§∏! ‡§Ü‡§™ ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è ‡§¨‡§ü‡§®‡•ã‡§Ç ‡§∏‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ ‡§î‡§∞ ‡§¨‡•â‡§ü ‡§ï‡•á ‡§´‡§º‡§Ç‡§ï‡•ç‡§∂‡§Ç‡§∏ ‡§ï‡§Ç‡§ü‡•ç‡§∞‡•ã‡§≤ ‡§ï‡§∞ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç‡•§\n"
        "‡§Ü‡§™‡§ï‡•á ‡§∏‡§≠‡•Ä ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§ï‡•ã ‡§§‡•ã‡§°‡§º‡§®‡•á ‡§™‡§∞ ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§ï‡•ã **‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ** ‡§Æ‡§ø‡§≤‡•á‡§ó‡•Ä‡•§\n\n"
        f"**‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ:** {punishment_text}\n"
        "__‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡•ã ‡§§‡•ã‡§°‡§º‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§ï‡•ã ‡§ï‡•å‡§®‡§∏‡•Ä ‡§∏‡§ú‡§º‡§æ ‡§¶‡•á‡§®‡•Ä ‡§π‡•à, ‡§µ‡•ã '‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ' ‡§∏‡•á ‡§ö‡•Å‡§®‡•á‡§Ç‡•§__"
    )

    # 4. Edit the message
    try:
        await client.edit_message_text(
            chat_id=chat_id,
            message_id=message_id,
            text=settings_message,
            reply_markup=keyboard,
            parse_mode=ParseMode.MARKDOWN
        )
    except Exception as e:
        logger.error(f"Failed to edit settings message in chat {chat_id}: {e}")


# -----------------------------------------------------
# NEW SETTINGS HANDLERS
# -----------------------------------------------------

@app.on_callback_query(filters.regex("open_group_settings"))
@app.on_callback_query(filters.regex("settings_back_to_main"))
async def open_settings_from_callback(client: Client, callback_query: CallbackQuery):
    """Opens or returns to the main settings menu."""
    if not await is_admin_or_owner(client, callback_query.message.chat.id, callback_query.from_user.id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    # Call the refresh function to display the main settings
    await refresh_settings_menu(
        client,
        callback_query.message.chat.id,
        callback_query.message.id,
        callback_query.from_user.id
    )
    await callback_query.answer()


@app.on_callback_query(filters.regex("^toggle_setting_"))
async def toggle_setting_callback(client: Client, callback_query: CallbackQuery):
    """Toggles a specific setting (bot_enabled, linkdel_enabled, etc.)."""
    chat_id = callback_query.message.chat.id
    user_id = callback_query.from_user.id
    setting_key = callback_query.data.replace("toggle_setting_", "")
    
    if not await is_admin_or_owner(client, chat_id, user_id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    # 1. Fetch current status
    current_status_doc = group_tracking_collection.find_one({"_id": chat_id})
    # Get the current value, defaulting to False for filters and True for bot_enabled
    default_value = True if setting_key == "bot_enabled" else False
    current_value = current_status_doc.get(setting_key, default_value) if current_status_doc else default_value
    
    # 2. Calculate the new value
    new_value = not current_value
    
    # 3. Update the database
    group_tracking_collection.update_one(
        {"_id": chat_id},
        {"$set": {setting_key: new_value}},
        upsert=True
    )
    
    # 4. Refresh the menu
    await refresh_settings_menu(client, chat_id, callback_query.message.id, user_id)
    
    # 5. Answer the query
    action_text = "‡§ö‡§æ‡§≤‡•Ç" if new_value else "‡§¨‡§Ç‡§¶"
    setting_name_map = {
        "bot_enabled": "‡§¨‡•â‡§ü ‡§ö‡•à‡§ü‡§ø‡§Ç‡§ó",
        "linkdel_enabled": "‡§≤‡§ø‡§Ç‡§ï ‡§°‡§ø‡§≤‡•Ä‡§ü",
        "biolinkdel_enabled": "‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§°‡§ø‡§≤‡•Ä‡§ü",
        "usernamedel_enabled": "@‡§Ø‡•Ç‡§ú‡§º‡§∞‡§®‡•á‡§Æ ‡§°‡§ø‡§≤‡•Ä‡§ü"
    }
    setting_name = setting_name_map.get(setting_key, setting_key)
    
    await callback_query.answer(f"{setting_name} ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï {action_text} ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à‡•§", show_alert=False)


@app.on_callback_query(filters.regex("open_punishment_settings"))
async def open_punishment_settings_callback(client: Client, callback_query: CallbackQuery):
    """Opens the submenu to select the default punishment."""
    chat_id = callback_query.message.chat.id
    user_id = callback_query.from_user.id

    if not await is_admin_or_owner(client, chat_id, user_id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    current_status_doc = group_tracking_collection.find_one({"_id": chat_id})
    current_punishment = current_status_doc.get("default_punishment", "delete") if current_status_doc else "delete"
    
    # Punishment buttons with checkmark for current selection
    def get_punishment_button(action, label):
        checkmark = "‚úÖ " if action == current_punishment else ""
        return InlineKeyboardButton(f"{checkmark}{label}", callback_data=f"set_punishment_{action}")

    keyboard = InlineKeyboardMarkup(
        [
            [
                get_punishment_button("delete", "üóëÔ∏è ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú"),
                get_punishment_button("mute", "üîá ‡§Æ‡•ç‡§Ø‡•Ç‡§ü ‡§ï‡§∞‡•á‡§Ç")
            ],
            [
                get_punishment_button("warn", "‚ö†Ô∏è ‡§µ‡§æ‡§∞‡•ç‡§® ‡§ï‡§∞‡•á‡§Ç"),
                get_punishment_button("ban", "‚õîÔ∏è ‡§¨‡•à‡§® ‡§ï‡§∞‡•á‡§Ç")
            ],
            [
                InlineKeyboardButton("üîô ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç", callback_data="settings_back_to_main")
            ]
        ]
    )
    
    punishment_message = (
        "üî® **‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏** üî®\n\n"
        "‡§µ‡§π ‡§ï‡§æ‡§∞‡•ç‡§∞‡§µ‡§æ‡§à ‡§ö‡•Å‡§®‡•á‡§Ç ‡§ú‡•ã ‡§¨‡•â‡§ü ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§™‡§∞ ‡§≤‡§æ‡§ó‡•Ç ‡§ï‡§∞‡•á‡§ó‡§æ ‡§ú‡§¨ ‡§µ‡•á ‡§ï‡§ø‡§∏‡•Ä ‡§≠‡•Ä **‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§®‡§ø‡§Ø‡§Æ** (‡§≤‡§ø‡§Ç‡§ï, ‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï, ‡§Ø‡•Ç‡§ú‡§º‡§∞‡§®‡•á‡§Æ) ‡§ï‡§æ ‡§â‡§≤‡•ç‡§≤‡§Ç‡§ò‡§® ‡§ï‡§∞‡•á‡§Ç‡§ó‡•á‡•§\n\n"
        f"**‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§∏‡§ú‡§º‡§æ:** **{current_punishment.upper()}**"
    )

    await client.edit_message_text(
        chat_id=chat_id,
        message_id=callback_query.message.id,
        text=punishment_message,
        reply_markup=keyboard,
        parse_mode=ParseMode.MARKDOWN
    )
    await callback_query.answer()


@app.on_callback_query(filters.regex("^set_punishment_"))
async def set_punishment_callback(client: Client, callback_query: CallbackQuery):
    """Sets the new default punishment and returns to the main settings."""
    chat_id = callback_query.message.chat.id
    user_id = callback_query.from_user.id
    new_punishment = callback_query.data.replace("set_punishment_", "")
    
    if not await is_admin_or_owner(client, chat_id, user_id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    # 1. Validate punishment
    valid_punishments = ["delete", "mute", "warn", "ban"]
    if new_punishment not in valid_punishments:
        await callback_query.answer("‡§Ö‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§∏‡§ú‡§º‡§æ ‡§µ‡§ø‡§ï‡§≤‡•ç‡§™‡•§", show_alert=True)
        return

    # 2. Update the database
    group_tracking_collection.update_one(
        {"_id": chat_id},
        {"$set": {"default_punishment": new_punishment}},
        upsert=True
    )
    
    # 3. Refresh the main menu
    await refresh_settings_menu(client, chat_id, callback_query.message.id, user_id)
    
    # 4. Answer the query
    punishment_map = {
        "delete": "‡§°‡§ø‡§≤‡•Ä‡§ü ‡§Æ‡•à‡§∏‡•á‡§ú",
        "mute": "‡§Æ‡•ç‡§Ø‡•Ç‡§ü",
        "warn": "‡§µ‡§æ‡§∞‡•ç‡§®",
        "ban": "‡§¨‡•à‡§®"
    }
    action_text = punishment_map.get(new_punishment, new_punishment).upper()
    await callback_query.answer(f"‡§°‡§ø‡§´‡§º‡•â‡§≤‡•ç‡§ü ‡§∏‡§ú‡§º‡§æ ‡§Ö‡§¨ **{action_text}** ‡§π‡•à‡•§", show_alert=True)


@app.on_callback_query(filters.regex("open_biolink_exceptions"))
async def open_biolink_exceptions_callback(client: Client, callback_query: CallbackQuery):
    """Displays the biolink exception menu."""
    chat_id = callback_query.message.chat.id
    user_id = callback_query.from_user.id
    
    if not await is_admin_or_owner(client, chat_id, user_id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    # 1. Fetch current exceptions for this chat
    exceptions = biolink_exceptions_collection.find_one({"_id": chat_id})
    exception_users = exceptions.get("user_ids", []) if exceptions else []
    
    # 2. Prepare the list of users (fetching usernames/first names is tricky here, so we show IDs for simplicity)
    list_text = "‡§ï‡•ã‡§à ‡§õ‡•Ç‡§ü ‡§®‡§π‡•Ä‡§Ç ‡§¶‡•Ä ‡§ó‡§à ‡§π‡•à‡•§ ü§∑‚Äç‚ôÄÔ∏è"
    if exception_users:
        list_text = "\n".join([f"‚Ä¢ `{uid}`" for uid in exception_users])

    message_text = (
        "üìù **‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§õ‡•Ç‡§ü (Exceptions)** üìù\n\n"
        "‡§ú‡§ø‡§® ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§Ü‡§™ ‡§â‡§®‡§ï‡•á ‡§¨‡§æ‡§Ø‡•ã ‡§Æ‡•á‡§Ç ‡§≤‡§ø‡§Ç‡§ï ‡§∞‡§ñ‡§®‡•á ‡§ï‡•Ä ‡§õ‡•Ç‡§ü ‡§¶‡•á‡§®‡§æ ‡§ö‡§æ‡§π‡§§‡•á ‡§π‡•à‡§Ç, ‡§â‡§®‡•ç‡§π‡•á‡§Ç ‡§Ø‡§π‡§æ‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç‡•§ \n"
        "‡§õ‡•Ç‡§ü ‡§¶‡•á‡§®‡•á ‡§Ø‡§æ ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§â‡§®‡§ï‡•á **‡§Ø‡•Ç‡§ú‡§º‡§∞ ID** ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        "**‡§µ‡§∞‡•ç‡§§‡§Æ‡§æ‡§® ‡§õ‡•Ç‡§ü ‡§µ‡§æ‡§≤‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏:**\n"
        f"{list_text}\n\n"
        "**‡§â‡§™‡§Ø‡•ã‡§ó:**\n"
        "‚Ä¢ ‡§õ‡•Ç‡§ü ‡§¶‡•á‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è: `/addbiolink <user_id>`\n"
        "‚Ä¢ ‡§õ‡•Ç‡§ü ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è: `/rembiolink <user_id>`\n\n"
        "_‡§Ø‡§π ‡§ï‡§Æ‡§æ‡§Ç‡§° ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§π‡•Ä ‡§ü‡§æ‡§á‡§™ ‡§ï‡§∞‡•á‡§Ç‡•§_"
    )

    keyboard = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üîô ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç", callback_data="settings_back_to_main")]
        ]
    )

    try:
        await client.edit_message_text(
            chat_id=chat_id,
            message_id=callback_query.message.id,
            text=message_text,
            reply_markup=keyboard,
            parse_mode=ParseMode.MARKDOWN
        )
    except Exception as e:
        logger.error(f"Failed to edit biolink exceptions message in chat {chat_id}: {e}")
        
    await callback_query.answer()


@app.on_callback_query(filters.regex("close_settings"))
async def close_settings_callback(client: Client, callback_query: CallbackQuery):
    """Closes and deletes the settings message."""
    chat_id = callback_query.message.chat.id
    user_id = callback_query.from_user.id

    if not await is_admin_or_owner(client, chat_id, user_id):
        await callback_query.answer("‡§Æ‡§æ‡§´‡§º ‡§ï‡§∞‡§®‡§æ, ‡§Ü‡§™ ‡§Ö‡§¨ ‡§è‡§°‡§Æ‡§ø‡§® ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    try:
        await client.delete_messages(
            chat_id=chat_id,
            message_ids=callback_query.message.id
        )
        await callback_query.answer("‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç ‡§¨‡§Ç‡§¶ ‡§ï‡§∞ ‡§¶‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ‡•§", show_alert=False)
    except Exception as e:
        # If deletion fails (e.g., bot not admin with delete rights)
        await callback_query.message.edit_text(
            "‚ùå **‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§¨‡§Ç‡§¶** ‚ùå\n\n_‡§Ø‡§π ‡§Æ‡•à‡§∏‡•á‡§ú 5 ‡§∏‡•á‡§ï‡§Ç‡§° ‡§Æ‡•á‡§Ç ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§π‡•ã ‡§ú‡§æ‡§è‡§ó‡§æ (‡§Ö‡§ó‡§∞ ‡§¨‡•â‡§ü ‡§ï‡•á ‡§™‡§æ‡§∏ ‡§™‡§∞‡§Æ‡§ø‡§∂‡§® ‡§π‡•à)‡•§_",
            reply_markup=None,
            parse_mode=ParseMode.MARKDOWN
        )
        await callback_query.answer("‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ ‡§¨‡§Ç‡§¶ ‡§π‡•ã ‡§ó‡§à ‡§π‡•à‡•§", show_alert=False)
        await asyncio.sleep(5)
        try:
            await client.delete_messages(chat_id, callback_query.message.id)
        except:
            pass # Ignore final failure

# -----------------------------------------------------
# EXISTING HANDLERS (UPDATED /HELP)
# -----------------------------------------------------

@app.on_callback_query(filters.regex("show_help_menu"))
async def show_help_menu_callback(client: Client, callback_query: CallbackQuery):
    logger.info(f"Help menu callback triggered by user {callback_query.from_user.id} in chat {callback_query.message.chat.id}")
    
    help_message = (
        "‡§Ø‡§π ‡§∞‡§π‡•Ä ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶, ‡§°‡§æ‡§∞‡•ç‡§≤‡§ø‡§Ç‡§ó! ü•∞\n\n"
        "**üë• ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ (‡§è‡§°‡§Æ‡§ø‡§® ‡§ï‡•á ‡§≤‡§ø‡§è):**\n"
        "‚Ä¢ `/settings` - **‡§∏‡§≠‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§∏‡•á‡§ü‡§ø‡§Ç‡§ó‡•ç‡§∏ (‡§ö‡•à‡§ü‡§ø‡§Ç‡§ó, ‡§≤‡§ø‡§Ç‡§ï‡•ç‡§∏, ‡§Ø‡•Ç‡§ú‡§º‡§∞‡§®‡•á‡§Æ ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§î‡§∞ ‡§∏‡§ú‡§º‡§æ) ‡§Æ‡•à‡§®‡•á‡§ú ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç ‡§ñ‡•ã‡§≤‡•á‡§Ç‡•§** (‡§®‡§Ø‡§æ!)\n"
        "‚Ä¢ `/addbiolink <user_id>` - ‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§∏‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§ï‡•ã ‡§õ‡•Ç‡§ü ‡§¶‡•á‡§Ç‡•§\n"
        "‚Ä¢ `/rembiolink <user_id>` - ‡§¨‡§æ‡§Ø‡•ã ‡§≤‡§ø‡§Ç‡§ï ‡§´‡§º‡§ø‡§≤‡•ç‡§ü‡§∞ ‡§∏‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞ ‡§ï‡•Ä ‡§õ‡•Ç‡§ü ‡§π‡§ü‡§æ‡§è‡§Å‡•§\n\n"
        "**üë§ ‡§∏‡§æ‡§Æ‡§æ‡§®‡•ç‡§Ø ‡§î‡§∞ ‡§®‡§ø‡§ú‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏:**\n"
        "‚Ä¢ `/start` - ‡§Æ‡•Å‡§ù‡•á ‡§∂‡•Å‡§∞‡•Ç ‡§ï‡§∞‡•ã!\n"
        "‚Ä¢ `/help` - ‡§Ø‡§π ‡§π‡•á‡§≤‡•ç‡§™ ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç ‡§¶‡§ø‡§ñ‡§æ‡§ì!\n"
        "‚Ä¢ `/topusers` - ‡§∏‡§¨‡§∏‡•á ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§¨‡§æ‡§§‡•á‡§Ç ‡§ï‡§∞‡§®‡•á ‡§µ‡§æ‡§≤‡•á ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏!\n"
        "‚Ä¢ `/stats check` - ‡§Æ‡•á‡§∞‡•Ä ‡§™‡§∞‡§´‡•â‡§∞‡•ç‡§Æ‡•á‡§Ç‡§∏ ‡§¶‡•á‡§ñ‡•ã! (‡§®‡§ø‡§ú‡•Ä ‡§ö‡•à‡§ü ‡§Æ‡•á‡§Ç)\n"
        "‚Ä¢ `/clearmydata` - ‡§Ö‡§™‡§®‡§æ ‡§∏‡§æ‡§∞‡§æ ‡§°‡•á‡§ü‡§æ ‡§°‡§ø‡§≤‡•Ä‡§ü ‡§ï‡§∞‡•ã!\n\n"
        "‡§Ö‡§ó‡§∞ ‡§ï‡•ã‡§à ‡§î‡§∞ ‡§Æ‡§¶‡§¶ ‡§ö‡§æ‡§π‡§ø‡§è, ‡§§‡•ã ‡§¨‡§∏ ‡§™‡•Ç‡§õ‡•ã! üòä"
    )

    keyboard = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üí∞ Earning Rules", callback_data="show_earning_rules")],
            [InlineKeyboardButton("üîô ‡§µ‡§æ‡§™‡§∏ ‡§ú‡§æ‡§è‡§Å", callback_data="start_menu_from_help")]
        ]
    )

    await callback_query.message.edit_text(
        text=help_message,
        reply_markup=keyboard,
        parse_mode=ParseMode.MARKDOWN
    )
    await callback_query.answer() 

# -----------------------------------------------------
# UNCHANGED EXISTING HANDLERS
# -----------------------------------------------------

@app.on_callback_query(filters.regex("show_earning_rules"))
async def show_earning_rules_callback(client: Client, callback_query: CallbackQuery):
    logger.info(f"Earning rules callback triggered by user {callback_query.from_user.id} in chat {callback_query.message.chat.id}")
    
    earning_rules_message = (
        "üí∞ **‡§™‡•à‡§∏‡•á ‡§ï‡§Æ‡§æ‡§®‡•á ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ!** üí∞\n\n"
        "‡§Ø‡§π‡§æ‡§Ç ‡§¨‡§§‡§æ‡§Ø‡§æ ‡§ó‡§Ø‡§æ ‡§π‡•à ‡§ï‡§ø ‡§Ü‡§™ ‡§Æ‡•á‡§∞‡•á ‡§∏‡§æ‡§• ‡§ï‡•à‡§∏‡•á ‡§ï‡§Æ‡§æ ‡§∏‡§ï‡§§‡•á ‡§π‡•à‡§Ç:\n"
        "1. **‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§∞‡§π‡•á‡§Ç:** ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§∏‡•á ‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡§∞‡•á‡§Ç ‡§î‡§∞ ‡§¨‡§æ‡§§‡§ö‡•Ä‡§§ ‡§Æ‡•á‡§Ç ‡§π‡§ø‡§∏‡•ç‡§∏‡§æ ‡§≤‡•á‡§Ç‡•§\n"
        "2. **‡§Æ‡§ú‡•á‡§¶‡§æ‡§∞ ‡§¨‡§®‡•á‡§Ç:** ‡§Ö‡§ö‡•ç‡§õ‡•á, ‡§ï‡•ç‡§µ‡§æ‡§≤‡§ø‡§ü‡•Ä ‡§µ‡§æ‡§≤‡•á ‡§î‡§∞ ‡§Æ‡§ú‡•á‡§¶‡§æ‡§∞ ‡§Æ‡•à‡§∏‡•á‡§ú ‡§ï‡§∞‡•á‡§Ç‡•§ ‡§∏‡•ç‡§™‡•à‡§Æ‡§ø‡§Ç‡§ó ‡§∏‡•á ‡§¨‡§ö‡•á‡§Ç!\n"
        "3. **‡§π‡§∞ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§∞‡•Ä‡§∏‡•á‡§ü:** ‡§π‡§∞ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§™‡§π‡§≤‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§ï‡•ã ‡§≤‡•Ä‡§°‡§∞‡§¨‡•ã‡§∞‡•ç‡§° ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§π‡•ã ‡§ú‡§æ‡§§‡§æ ‡§π‡•à, ‡§§‡§æ‡§ï‡§ø ‡§∏‡§¨‡§ï‡•ã ‡§Æ‡•å‡§ï‡§æ ‡§Æ‡§ø‡§≤‡•á!\n"
        "4. **‡§™‡•Å‡§∞‡§∏‡•ç‡§ï‡§æ‡§∞:** ‡§ü‡•â‡§™ ‡§Ø‡•Ç‡§ú‡§º‡§∞‡•ç‡§∏ ‡§ï‡•ã ‡§π‡§∞ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§®‡§ï‡§¶ ‡§™‡•Å‡§∞‡§∏‡•ç‡§ï‡§æ‡§∞ ‡§Ø‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§∏‡§¨‡•ç‡§∏‡§ï‡•ç‡§∞‡§ø‡§™‡•ç‡§∂‡§® ‡§Æ‡§ø‡§≤‡§§‡•á ‡§π‡•à‡§Ç‡•§\n\n"
        f"‡§ú‡§º‡•ç‡§Ø‡§æ‡§¶‡§æ ‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§ï‡•á ‡§≤‡§ø‡§è ‡§Æ‡•á‡§∞‡•á ‡§Æ‡§æ‡§≤‡§ø‡§ï @{ASBHAI_USERNAME} ‡§∏‡•á ‡§∏‡§Ç‡§™‡§∞‡•ç‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§\n\n"
        "‡§ö‡§≤‡•ã, ‡§Ö‡§¨ ‡§¨‡§æ‡§§‡•á‡§Ç ‡§ï‡§∞‡•ã ‡§î‡§∞ ‡§ú‡•Ä‡§§‡•ã! üöÄ"
    )

    keyboard = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("üîô Earning Leaderboard", callback_data="show_earning_leaderboard")]
        ]
    )

    await callback_query.message.edit_text(
        text=earning_rules_message,
        reply_markup=keyboard,
        parse_mode=ParseMode.MARKDOWN
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex("start_menu_from_help"))
async def back_to_start_from_help(client: Client, callback_query: CallbackQuery):
    logger.info(f"Back to start menu from help triggered by user {callback_query.from_user.id} in chat {callback_query.message.chat.id}")
    
    user_name = callback_query.from_user.first_name if callback_query.from_user else "Dost"
    welcome_message = (
        f"üåü ‡§π‡•á **{user_name}** ‡§ú‡§æ‡§®‡•Ç! ‡§Ü‡§™‡§ï‡§æ ‡§∏‡•ç‡§µ‡§æ‡§ó‡§§ ‡§π‡•à! üåü\n\n"
        "‡§Æ‡•à‡§Ç ‡§Ü‡§™‡§ï‡•Ä ‡§Æ‡§¶‡§¶ ‡§ï‡§∞‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§§‡•à‡§Ø‡§æ‡§∞ ‡§π‡•Ç‡§Å!\n"
        "‡§Ö‡§™‡§®‡•Ä ‡§∏‡§≠‡•Ä ‡§ï‡§Æ‡§æ‡§Ç‡§°‡•ç‡§∏ ‡§¶‡•á‡§ñ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è ‡§®‡•Ä‡§ö‡•á ‡§¶‡§ø‡§è ‡§ó‡§è '‡§∏‡§π‡§æ‡§Ø‡§§‡§æ' ‡§¨‡§ü‡§® ‡§™‡§∞ ‡§ï‡•ç‡§≤‡§ø‡§ï ‡§ï‡§∞‡•á‡§Ç‡•§"
    )
    keyboard = InlineKeyboardMarkup(
        [
            [InlineKeyboardButton("‚ûï ‡§Æ‡•Å‡§ù‡•á ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§Æ‡•á‡§Ç ‡§ú‡•ã‡§°‡§º‡•á‡§Ç", url=f"https://t.me/{client.me.username}?startgroup=true")],
            [
                InlineKeyboardButton("üì£ Updates Channel", url=f"https://t.me/{UPDATE_CHANNEL_USERNAME}"),
                InlineKeyboardButton("‚ùì Support Group", url="https://t.me/aschat_group")
            ],
            [
                InlineKeyboardButton("‚ÑπÔ∏è ‡§∏‡§π‡§æ‡§Ø‡§§‡§æ ‚ùì", callback_data="show_help_menu"),
                InlineKeyboardButton("üí∞ Earning Leaderboard", callback_data="show_earning_leaderboard")
            ]
        ]
    )
    # ‡§´‡•ã‡§ü‡•ã ‡§π‡§ü‡§æ‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è edit_message_text ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç
    await callback_query.message.edit_text(
        text=welcome_message,
        reply_markup=keyboard,
        parse_mode=ParseMode.MARKDOWN,
        disable_web_page_preview=True 
    )
    await callback_query.answer()

@app.on_callback_query(filters.regex("show_earning_leaderboard"))
async def show_earning_leaderboard_callback(client: Client, callback_query: CallbackQuery):
    logger.info(f"Earning leaderboard callback triggered by user {callback_query.from_user.id} in chat {callback_query.message.chat.id}")
    
    top_users = await get_top_earning_users()
    if not top_users:
        keyboard = InlineKeyboardMarkup(
            [[InlineKeyboardButton("üîô ‡§Æ‡•Å‡§ñ‡•ç‡§Ø ‡§Æ‡•á‡§®‡•ç‡§Ø‡•Ç", callback_data="start_menu_from_help")]]
        )
        await callback_query.message.edit_text(text="üò¢ ‡§Ö‡§¨ ‡§§‡§ï ‡§ï‡•ã‡§à ‡§≠‡•Ä ‡§â‡§™‡§Ø‡•ã‡§ó‡§ï‡§∞‡•ç‡§§‡§æ ‡§≤‡•Ä‡§°‡§∞‡§¨‡•ã‡§∞‡•ç‡§° ‡§™‡§∞ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à! ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§π‡•ã‡§ï‡§∞ ‡§™‡§π‡§≤‡•á ‡§¨‡§®‡•á‡§Ç! ‚ú®\n\n**Powered By:** @asbhaibsr", parse_mode=ParseMode.MARKDOWN, reply_markup=keyboard)
        await callback_query.answer()
        return

    earning_messages = ["üëë **Top Active Users - ‚ú® VIP Leaderboard! ‚ú®** üëë\n\n"]
    prizes = {
        1: "üí∞ ‚Çπ50", 2: "üí∏ ‚Çπ30", 3: "üéÅ ‚Çπ20",
        4: f"üé¨ @{ASFILTER_BOT_USERNAME} ‡§ï‡§æ 1 ‡§π‡§´‡§º‡•ç‡§§‡•á ‡§ï‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§™‡•ç‡§≤‡§æ‡§®",
        5: f"üé¨ @{ASFILTER_BOT_USERNAME} ‡§ï‡§æ 3 ‡§¶‡§ø‡§® ‡§ï‡§æ ‡§™‡•ç‡§∞‡•Ä‡§Æ‡§ø‡§Ø‡§Æ ‡§™‡•ç‡§≤‡§æ‡§®"
    }

    for i, user in enumerate(top_users[:5]):
        rank = i + 1
        user_name = user.get('first_name', 'Unknown User')
        username_str = f"@{user.get('username')}" if user.get('username') else f"ID: `{user.get('user_id')}`"
        message_count = user.get('message_count', 0)
        prize_str = prizes.get(rank, "üèÖ ‡§ï‡•ã‡§à ‡§™‡•Å‡§∞‡§∏‡•ç‡§ï‡§æ‡§∞ ‡§®‡§π‡•Ä‡§Ç")

        group_info = ""
        last_group_id = user.get('last_active_group_id')
        last_group_title = user.get('last_active_group_title', 'Unknown Group')

        if last_group_id:
            try:
                chat_obj = await client.get_chat(last_group_id)
                if chat_obj.type == ChatType.PRIVATE:
                    group_info = f"   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **[‡§®‡§ø‡§ú‡•Ä ‡§ö‡•à‡§ü ‡§Æ‡•á‡§Ç](tg://user?id={user.get('user_id')})**\n"
                elif chat_obj.username:
                    group_info = f"   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **[{chat_obj.title}](https://t.me/{chat_obj.username})**\n"
                else:
                    try:
                        invite_link = await client.export_chat_invite_link(last_group_id)
                        group_info = f"   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **[{chat_obj.title}]({invite_link})**\n"
                    except Exception:
                        group_info = f"   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **{chat_obj.title}** (‡§®‡§ø‡§ú‡•Ä ‡§ó‡•ç‡§∞‡•Å‡§™)\n"
            except Exception as e:
                logger.warning(f"Could not fetch chat info for group ID {last_group_id} for leaderboard: {e}")
                group_info = f"   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **{last_group_title}** (‡§ú‡§æ‡§®‡§ï‡§æ‡§∞‡•Ä ‡§â‡§™‡§≤‡§¨‡•ç‡§ß ‡§®‡§π‡•Ä‡§Ç)\n"
        else:
            group_info = "   ‚Ä¢ ‡§∏‡§ï‡•ç‡§∞‡§ø‡§Ø ‡§•‡§æ: **‡§ï‡•ã‡§à ‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ó‡§§‡§ø‡§µ‡§ø‡§ß‡§ø ‡§®‡§π‡•Ä‡§Ç**\n"

        earning_messages.append(
            f"**{rank}.** üåü **{user_name}** ({username_str}) üåü\n"
            f"   ‚Ä¢ ‡§ï‡•Å‡§≤ ‡§Æ‡•à‡§∏‡•á‡§ú: **{message_count} üí¨**\n"
            f"   ‚Ä¢ ‡§∏‡§Ç‡§≠‡§æ‡§µ‡§ø‡§§ ‡§™‡•Å‡§∞‡§∏‡•ç‡§ï‡§æ‡§∞: **{prize_str}**\n"
            f"{group_info}"
        )
    
    earning_messages.append(
        "\n_‡§π‡§∞ ‡§Æ‡§π‡•Ä‡§®‡•á ‡§ï‡•Ä ‡§™‡§π‡§≤‡•Ä ‡§§‡§æ‡§∞‡•Ä‡§ñ ‡§ï‡•ã ‡§Ø‡§π ‡§∏‡§ø‡§∏‡•ç‡§ü‡§Æ ‡§∞‡•Ä‡§∏‡•á‡§ü ‡§π‡•ã‡§§‡§æ ‡§π‡•à!_\n"
        "_‡§ó‡•ç‡§∞‡•Å‡§™ ‡§ï‡•á ‡§®‡§ø‡§Ø‡§Æ‡•ã‡§Ç ‡§ï‡•ã ‡§ú‡§æ‡§®‡§®‡•á ‡§ï‡•á ‡§≤‡§ø‡§è `/help` ‡§ï‡§æ ‡§â‡§™‡§Ø‡•ã‡§ó ‡§ï‡§∞‡•á‡§Ç‡•§_"
    )
    keyboard = InlineKeyboardMarkup(
        [
            [
                InlineKeyboardButton("üí∞ ‡§™‡•à‡§∏‡•á ‡§®‡§ø‡§ï‡§≤‡§µ‡§æ‡§è‡§Å (Withdraw)", url=f"https://t.me/{ASBHAI_USERNAME}"),
                InlineKeyboardButton("üí∞ Earning Rules", callback_data="show_earning_rules")
            ]
        ]
    )
    await callback_query.message.edit_text(text="\n".join(earning_messages), reply_markup=keyboard, parse_mode=ParseMode.MARKDOWN, disable_web_page_preview=True)
    await callback_query.answer()

# --- clearall_dbs ‡§ï‡•á ‡§≤‡§ø‡§è ‡§ï‡•â‡§≤‡§¨‡•à‡§ï ‡§π‡•à‡§Ç‡§°‡§≤‡§∞ (UNCHANGED) ---
@app.on_callback_query(filters.regex("confirm_clearall_dbs"))
async def confirm_clearall_dbs_callback(client: Client, callback_query: CallbackQuery):
    logger.info(f"Clear All DBs confirmation received from owner {callback_query.from_user.id}")
    if callback_query.from_user.id != OWNER_ID:
        await callback_query.answer("‡§Ü‡§™ ‡§Ö‡§ß‡§ø‡§ï‡•É‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return

    try:
        messages_collection.drop()
        buttons_collection.drop()
        group_tracking_collection.drop()
        user_tracking_collection.drop()
        owner_taught_responses_collection.drop()
        conversational_learning_collection.drop()
        biolink_exceptions_collection.drop()
        earning_tracking_collection.drop()
        reset_status_collection.drop()

        await callback_query.message.edit_text(
            "üéâ **‡§¨‡•â‡§∏! ‡§Ü‡§™‡§ï‡§æ ‡§™‡•Ç‡§∞‡§æ ‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§∏‡§´‡§º‡§æ‡§à ‡§∏‡•á ‡§ö‡§Æ‡§ï ‡§∞‡§π‡§æ ‡§π‡•à!** ‚ú®\n"
            "‡§∏‡§≠‡•Ä ‡§∏‡§Ç‡§ó‡•ç‡§∞‡§π (collections) ‡§∏‡§´‡§≤‡§§‡§æ‡§™‡•Ç‡§∞‡•ç‡§µ‡§ï ‡§π‡§ü‡§æ ‡§¶‡§ø‡§è ‡§ó‡§è ‡§π‡•à‡§Ç‡•§\n"
            "‡§è‡§ï‡§¶‡§Æ ‡§®‡§Ø‡§æ ‡§∏‡•ç‡§ü‡§æ‡§∞‡•ç‡§ü! üöÄ",
            parse_mode=ParseMode.MARKDOWN
        )
        logger.info(f"Owner {callback_query.from_user.id} successfully cleared all MongoDB collections.")
    except Exception as e:
        await callback_query.message.edit_text(
            f"‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§∏‡§æ‡§´‡§º ‡§ï‡§∞‡§§‡•á ‡§∏‡§Æ‡§Ø ‡§è‡§∞‡§∞: {e}. ‡§ì‡§π ‡§®‡•ã! üò±",
            parse_mode=ParseMode.MARKDOWN
        )
        logger.error(f"Error clearing all databases: {e}")
    
    await callback_query.answer("‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§∏‡§æ‡§´‡§º ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!", show_alert=True)

@app.on_callback_query(filters.regex("cancel_clearall_dbs"))
async def cancel_clearall_dbs_callback(client: Client, callback_query: CallbackQuery):
    logger.info(f"Clear All DBs cancellation received from owner {callback_query.from_user.id}")
    if callback_query.from_user.id != OWNER_ID:
        await callback_query.answer("‡§Ü‡§™ ‡§Ö‡§ß‡§ø‡§ï‡•É‡§§ ‡§®‡§π‡•Ä‡§Ç ‡§π‡•à‡§Ç‡•§", show_alert=True)
        return
    
    await callback_query.message.edit_text(
        "‡§†‡•Ä‡§ï ‡§π‡•à! ‚úÖ ‡§°‡•á‡§ü‡§æ‡§¨‡•á‡§∏ ‡§ï‡•Ä ‡§∏‡§´‡§º‡§æ‡§à ‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§∞ ‡§¶‡•Ä ‡§ó‡§à ‡§π‡•à‡•§\n"
        "‡§Ü‡§™‡§ï‡§æ ‡§°‡•á‡§ü‡§æ ‡§∏‡•Å‡§∞‡§ï‡•ç‡§∑‡§ø‡§§ ‡§π‡•à‡•§ üòâ",
        parse_mode=ParseMode.MARKDOWN
    )
    await callback_query.answer("‡§∞‡§¶‡•ç‡§¶ ‡§ï‡§ø‡§Ø‡§æ ‡§ó‡§Ø‡§æ!", show_alert=True)
